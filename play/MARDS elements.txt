MARDS elements

The default for any entry in a MARDS Schema Document is:

    name <name>
        value
            type string

-----------------------
TREATMENT TYPES
-----------------------

A 'value' can have a 'treatment' which changes the interpretive behavior on the MARDS document.

list

    This is the default.
    Zero or more entries are expected as a list.
    
    example:
    
        output joe
        output larry
        output joe
        output george
        
    would be a list:
        output -> [joe, larry, joe, george]
    
unique

    Zero or more entries are expected as a list, but NONE of the entries
    are repeats of each other.
    
    example:
    
        output joe
        output larry
        output george
        
    would be a list:
        output -> [joe, larry, george]
    or could be a dictionary:
        output -> {'joe': None, 'larry': None, 'george': None}
        
sum

    Zero or more entries are expected, but they are "summarized" in a manner that
    makes sense for their 'type'.

    example (if output is of type 'number'):
    
        output 3
        output 6
        output 3

    would be a number:
        output -> 12
        
    For the 'string' and 'label' types, each entry is concatenated with a '\n' between
    them.

    example:
    
        output joe
        output larry
        output george

    would be a string:
        output -> "joe\nlarry\ngeorge"
       
        
average

    Zero or more entries are expected, but they are "averaged" in a manner that
    makes sense for their 'type'. The 'string' and 'label' types treat an average as the
    same thing as a 'sum'.

    example (if output is of type 'number'):
    
        output 3
        output 6
        output 3

    would be a number:
        output -> 4
        
one

    Exactly one entry is expected. If there is more than one entry, then only the
    first entry is considered. Additional entries are errors.
    If there are zero entries, then all is okay unless there are 'required' entries.
    
    example:
    
        id joe

    would be a string:
        id -> "joe"

-----------------
'required' entries
-----------------

The schema allows for a 'required' entry. This entry represents whether or not
a particular element may be missing.

For example, if one where to put a required entry in the context of a 'name', that would
indicated that the document must have at least ONE 'id' in it.

    SCHEMA FRAGMENT:

        name id
            required

    GOOD:
    
        blah 4
        id
        output joe

    GOOD:
    
        blah 4
        output joe 
        
        
The second scenario is also good because the software will simply insert the named
entry with no value:
        
        blah 4
        id
        output joe

If one where to add the 'required' entry to a 'value' entry, then the value must
not be missing.


    SCHEMA FRAGMENT:

        name id
            value
                required

    GOOD:
    
        blah 4
        id zip
        output joe

    GOOD:
    
        blah 4
        output joe

    BAD:
    
        blah 4
        id
        output joe

If both 'name' and the 'value' entries have a 'required' entry, then both the name
and the value must exist:

    SCHEMA FRAGMENT
        
        name id
            required
            value
                required

    GOOD:
    
        blah 4
        id zip
        output joe

    BAD:
    
        blah 4
        id
        output joe 

    BAD:
    
        blah 4
        output joe 

        
-------------------------
Adding 'default' to 'required'
-------------------------

The 'default' entry changes the behavior of 'required'. It 'creates' a solution
to a missing entry.

Note: the 'default' entry has no meaning without a 'required' entry.

Example 1 (only name is required):

    SCHEMA FRAGMENT
        
        name id
            required
            value
                default hello

    GOOD:
    
        blah 4
        id zip
        output joe
        # id is 'zip'

    GOOD:
    
        blah 4
        id
        output joe 
        # id has no value

    GOOD:
    
        blah 4
        output joe
        # id is 'hello'
        

Example 2 (only value is required):

    SCHEMA FRAGMENT
        
        name id
            value
                required
                default hello

    GOOD:
    
        blah 4
        id zip
        output joe
        # id is 'zip'

    GOOD:
    
        blah 4
        id
        output joe 
        # id is 'hello'

    GOOD:
    
        blah 4
        output joe
        # there is no id
        
Example 3 (both name and value are required):

    SCHEMA FRAGMENT
        
        name id
            required
            value
                required
                default hello

    GOOD:
    
        blah 4
        id zip
        output joe
        # id is 'zip'

    GOOD:
    
        blah 4
        id
        output joe 
        # id is 'hello'

    GOOD:
    
        blah 4
        output joe
        # id is 'hello'
        
----------------- 
the 'ordered' flag
-----------------

The 'ordered' flag determines the overall need to retain the contextual order. The DEFAULT is yes. So if
the schema does not have the 'ordered' element, then the context must retain order.

    SCHEMA FRAGMENT
        
        name blah
        name output
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    DIFFERENT:
    
        output joe
        output jerry
        blah 1
        blah 2

    JSON INTERPRETATION:
    
        [(blah, 1), (blah, 2), (output, joe), (output, jerry)]

    This is different because the 'name' context is ordered. Even though the
    'output' and 'blah' lists happen to be in order, the grouping of 'output'
    and 'blah' are not in order any more.
    
An example of order being turned off in the 'name' context:

    SCHEMA FRAGMENT
        
        ordered False
        name blah
        name output
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    SAME:
    
        output joe
        output jerry
        blah 1
        blah 2

    SAME:
    
        output joe
        blah 1
        output jerry
        blah 2
        
    JSON INTERPRETATION:
    
        {blah: [1, 2], output: [joe, jerry]}

    Since the name context is no longer important, the relative order of the 'blah' and
    'output' lists are not important. It is only important that the order is retained
    inside the lists.
    
An example of order being turned off in the 'value' context:

    SCHEMA FRAGMENT
        
        name blah
            value
                ordered False
        name output
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    SAME:
    
        blah 2
        blah 1
        output joe
        output jerry

    DIFFERENT:
    
        output joe
        output jerry
        blah 1
        blah 2

    JSON INTERPRETATION:
    
        [(blah, 1), (blah, 2), (output, joe), (output, jerry)]

    The 'values' for 'blah' are not ordered, so having [2,1] is the same as [1,2]. However, the
    relative placement of 'output' and 'blah' entries must retain their order.

An example of order being turned both the 'value' and 'name' contexts:

    SCHEMA FRAGMENT
        
        ordered False
        name blah
            value
                ordered False
        name output
            value
                ordered False
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    SAME:
    
        output jerry
        output joe
        blah 2
        blah 1

    JSON INTERPRETATION:
    
        {blah: {1: None, 2:None}, output: {joe: None, jerry: None}}
        
    or

        {blah: [1, 2], output: [joe, jerry]}
    
    None of the entries have a retained order. As long as the same four named
    elements are in the document, the order is not important.
    
    
--------------------------------------
JSON and Pythonic INTEPRETATION
--------------------------------------

The following elements can influence interpretation:

* 'treatment' statements
* 'ordered' statements in name and value contexts
* existence of subtending 'name' entries in the schema

THE DEFAULT:

As a worst-case fallback, a MARDS document is represented as a list-of-tuples containing lists-of-tuples. It is the form of:

  [(name, value, _list_), ...]
  
Where list _can_ be another list of (name, value, list) to subtend the name/value.
  
For example:

    SCHEMA:
    
        name blah
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = [
        ('blah', '1', [
            ('size', 'x'),
            ('size', 'xl')
        ]),
        ('blah', '1', [
            ('size', 'x'),
            ('size', 'xl')
        ]),
        ('output', 'joe'),
        ('output, 'jerry'),
        ('corn', '1994')
    ]
    
    # code to get the sizes of 'blah 1'
    size_items = [x[2] for x in doc if x[0]=='blah' and x[1]=='1']
    sizes = [x[1] for x in size_items[0]]
    
    # code to get the 'corn' value
    corn_year = [x[1] for x in doc if x[0]=='corn'][0]

ORDERED

Adding an 'ordered' statement of 'False' to the 'name' context converts a
name to a dicitonary key and any subtending values to a list (or list of
tuples). For example:

    SCHEMA:

        ordered False
        name blah
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': [
            ('1', [
                ('size', 'x'),
                ('size', 'xl')
            ]),
            ('2', [
                ('size', 'sm'),
                ('size', 'x')
            ]),
        'output': ['joe', 'jerry'],
        'corn': ['1994']
    }

    # code to get the sizes of 'blah 1'
    size_list = [x[1] for x in doc['blah'] if x[0]=='1']
    sizes = [x[1] for x in size_list]
    
    # code to get the 'corn' value
    corn_year = doc['corn'][0]

Going even further:

    SCHEMA:

        ordered False
        name blah
            ordered False
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': [
            ('1', {'size': ['x', 'xl']}),
            ('2', {'size': ['sm', 'x']})
        ],
        'output': ['joe', 'jerry'],
        'corn': ['1994']
    }

    # code to get the sizes of 'blah 1'
    sizes = [x[1]['size'] for x in doc['blah'] if x[0]=='1']
    
    # code to get the 'corn' value
    corn_year = doc['corn'][0]

    
If the 'ordered False' is used in a value context, then the those values are
used as dictionary keys IF there are any subtending name elements in the schema.
Otherwise it is still a list.

To keep things consistent, it is existence of 'name' elements in the schema that
determine the behavior, whether they are actually in the document is not important.

Example:
    
    SCHEMA:

        ordered False
        name blah
            ordered False
            value
                ordered False
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': {
            '1': {'size': ['x', 'xl']},
            '2': {'size': ['sm', 'x']}
        },
        'output': ['joe', 'jerry'],
        'corn': ['1994']
    }

    # code to get the sizes of 'blah 1'
    sizes = doc['blah']['1']['size']
    
    # code to get the 'corn' value
    corn_year = doc['corn'][0]

    
TREATMENT ONE, SUM, and AVERAGE

Adding a treament of 'one', 'sum', or 'average' to a name context, will
change the intpretation of the document. Specifically, it removes the
'list-like' behavior of the value IF it is already in the context of a
dictionary.

For example:

    SCHEMA:

        ordered False
        name blah
            ordered False
            value
                ordered False
            name size
        name output
        name corn
            treatment one
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': {
            '1': {'size': ['x', 'xl']},
            '2': {'size': ['sm', 'x']}
        },
        'output': ['joe', 'jerry'],
        'corn': '1994'
    }

    # code to get the sizes of 'blah 1'
    sizes = doc['blah']['1']['size']
    
    # code to get the 'corn' value
    corn_year = doc['corn']

NOTE regarding ROLNE

The rolne data type, if used rather than python's built-in types, also makes
queries easy. The 'ordered' and 'treatment' clues are simply not needed. Using
the same example:

    SCHEMA:

        name blah
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

    ROLNE CODE in Python:
        
    doc = MARDS.MARDS_to_rolne(text_document)    
    
    # code to get the sizes of 'blah 1'
    sizes = doc['blah', '1'].get_list("size")
    
    # code to get the (first) 'corn' value
    corn_year = doc.value('corn')

-------------------------
RECURSION
-------------------------

The MARDS schema supports recursion, but in a more direct manner than other
markup and serialization formats. Recursive references use a 'recurse' rather
than 'name' element.

Example:

    SCHEMA
    
        name document_title
        name summary
        name section
            value
                required
            name description
            recurse section

    EXAMPLE DOC
    
        document_title "The MARDS Manual"
        summary "A simply splendid manual explaining MARDS"
        section "Chapter 1"
            description "Introduction"
            section "1.1"
                description "About Me"
            section "1.2"
                description "Standards Used"
            section "2.3"
                description "Why Mards?"
                section "2.3.1"
                    descrption "No, seriously, why Mards?"
        section "Chapter 2"
            description "More Stuff"
        section "Chapter 3"
            description "blah blah blah"
            

RULE ONE: In order for the 'recurse' reference to work, the name label is refers to must
be unique. It cannot be used any where else in the document. In the previous example,
'name section' connot appear in any other place. There can, however, be multiple
'recurse section' references.

RULE TWO: The 'recurse' reference cannot have any additional name or value elements
subtending it.

Only the schema document can be recursive. A data document cannot be. 

----------------------------
TYPES
----------------------------

A new type is defined with a 'define_type' element.

Typically, a 'define_type' is first defined at the root of the document. If a type is defined at any
other level of indentation, then that type is limited to that context. While this is
possible, it is a highly discouranged practice.

Example:

    SCHEMA:
    
        define_type length
            regex "\s*([0-9][0-9]*.?[0-9]*)\s*(\w*)\s*"
                group length
                group unit
                    find mm
                        calc length
                            formula n*1000
                    find cm
                        calc length
                            formula n*100
            extern_support True
            return length
            
        define_type boolean
            regex "\s*(.*)\s*"
                group bool
                    find true
                    find True
                        replace_with true
                    find 1
                        replace_with true
                    find false
                    find False
                        replace_with false
                    find 0
                        replace_with false
                    find_else_reject true
            extern_support False
            return bool

-------------------------------------
IMPORTS
-------------------------------------

%%MARDS_en_1.0 local:thename

There can ONLY be one schema for a data document


%%MARDS_schema_en_1.0
import 3rdpart
    from library
import boolean
    from library
    named my_boolean
import my_type
    from http://www.outthere.com/my_type.mards
import integer
    from common
import length
    from common

'from' is either 'common', 'library', 'local', or a URI.

The _exact_ meaning of these depends somewhat on the implementation:
   'common' are the default types set by version 1.0 of the spec
   'library' are types managed by whoever designed the MARDS library
   'local' means a schema document in the same location as this document
   a URL is a standardized uri used to retreive the MARDS schema doc.
   
    
Ter