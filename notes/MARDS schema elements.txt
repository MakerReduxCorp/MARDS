MARDS elements

The default for any entry in a MARDS Schema Document is:

    name <name>
        value
            type string

-----------------------
TREATMENT TYPES
-----------------------

A 'value' can have a 'treatment' which changes the interpretive behavior on the MARDS document.

list

    This is the default.
    Zero or more entries are expected as a list.
    
    example:
    
        output joe
        output larry
        output joe
        output george
        
    would be a list:
        output -> [joe, larry, joe, george]
    
unique

    Zero or more entries are expected as a list, but NONE of the entries
    are repeats of each other.
    
    example:
    
        output joe
        output larry
        output george
        
    would be a list:
        output -> [joe, larry, george]
    or could be a dictionary:
        output -> {'joe': None, 'larry': None, 'george': None}
        
sum

    Zero or more entries are expected, but they are "summarized" in a manner that
    makes sense for their 'type'.

    example (if output is of type 'number'):
    
        output 3
        output 6
        output 3

    would be a number:
        output -> 12
        
    For the 'string' and 'label' types, each entry is concatenated with a '\n' between
    them.

    example:
    
        output joe
        output larry
        output george

    would be a string:
        output -> "joe\nlarry\ngeorge"
       
        
average

    Zero or more entries are expected, but they are "averaged" in a manner that
    makes sense for their 'type'. The 'string' and 'label' types treat an average as the
    same thing as a 'sum'.

    example (if output is of type 'number'):
    
        output 3
        output 6
        output 3

    would be a number:
        output -> 4
        
one

    Exactly one entry is expected. If there is more than one entry, then only the
    first entry is considered. Additional entries are errors.
    If there are zero entries, then all is okay unless there are 'required' entries.
    
    example:
    
        id joe

    would be a string:
        id -> "joe"

-----------------
'required' entries
-----------------

The schema allows for a 'required' entry. This entry represents whether or not
a particular element may be missing.

For example, if one where to put a required entry in the context of a 'name', that would
indicated that the document must have at least ONE 'id' in it.

    SCHEMA FRAGMENT:

        name id
            required

    GOOD:
    
        blah 4
        id
        output joe

    GOOD:
    
        blah 4
        output joe 
        
        
The second scenario is also good because the software will simply insert the named
entry with no value:
        
        blah 4
        id
        output joe

If one where to add the 'required' entry to a 'value' entry, then the value must
not be missing.


    SCHEMA FRAGMENT:

        name id
            value
                required

    GOOD:
    
        blah 4
        id zip
        output joe

    GOOD:
    
        blah 4
        output joe

    BAD:
    
        blah 4
        id
        output joe

If both 'name' and the 'value' entries have a 'required' entry, then both the name
and the value must exist:

    SCHEMA FRAGMENT
        
        name id
            required
            value
                required

    GOOD:
    
        blah 4
        id zip
        output joe

    BAD:
    
        blah 4
        id
        output joe 

    BAD:
    
        blah 4
        output joe 

        
-------------------------
Adding 'default' to 'required'
-------------------------

The 'default' entry changes the behavior of 'required'. It 'creates' a solution
to a missing entry.

Note: the 'default' entry has no meaning without a 'required' entry.

Example 1 (only name is required):

    SCHEMA FRAGMENT
        
        name id
            required
            value
                default hello

    GOOD:
    
        blah 4
        id zip
        output joe
        # id is 'zip'

    GOOD:
    
        blah 4
        id
        output joe 
        # id has no value

    GOOD:
    
        blah 4
        output joe
        # id is 'hello'
        

Example 2 (only value is required):

    SCHEMA FRAGMENT
        
        name id
            value
                required
                default hello

    GOOD:
    
        blah 4
        id zip
        output joe
        # id is 'zip'

    GOOD:
    
        blah 4
        id
        output joe 
        # id is 'hello'

    GOOD:
    
        blah 4
        output joe
        # there is no id
        
Example 3 (both name and value are required):

    SCHEMA FRAGMENT
        
        name id
            required
            value
                required
                default hello

    GOOD:
    
        blah 4
        id zip
        output joe
        # id is 'zip'

    GOOD:
    
        blah 4
        id
        output joe 
        # id is 'hello'

    GOOD:
    
        blah 4
        output joe
        # id is 'hello'
        
----------------- 
the 'ordered' flag
-----------------

The 'ordered' flag determines the overall need to retain the contextual order. The DEFAULT is yes. So if
the schema does not have the 'ordered' element, then the context must retain order.

    SCHEMA FRAGMENT
        
        name blah
        name output
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    DIFFERENT:
    
        output joe
        output jerry
        blah 1
        blah 2

    JSON INTERPRETATION:
    
        [(blah, 1), (blah, 2), (output, joe), (output, jerry)]

    This is different because the 'name' context is ordered. Even though the
    'output' and 'blah' lists happen to be in order, the grouping of 'output'
    and 'blah' are not in order any more.
    
An example of order being turned off in the 'name' context:

    SCHEMA FRAGMENT
        
        ordered False
        name blah
        name output
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    SAME:
    
        output joe
        output jerry
        blah 1
        blah 2

    SAME:
    
        output joe
        blah 1
        output jerry
        blah 2
        
    JSON INTERPRETATION:
    
        {blah: [1, 2], output: [joe, jerry]}

    Since the name context is no longer important, the relative order of the 'blah' and
    'output' lists are not important. It is only important that the order is retained
    inside the lists.
    
An example of order being turned off in the 'value' context:

    SCHEMA FRAGMENT
        
        name blah
            value
                ordered False
        name output
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    SAME:
    
        blah 2
        blah 1
        output joe
        output jerry

    DIFFERENT:
    
        output joe
        output jerry
        blah 1
        blah 2

    JSON INTERPRETATION:
    
        [(blah, 1), (blah, 2), (output, joe), (output, jerry)]

    The 'values' for 'blah' are not ordered, so having [2,1] is the same as [1,2]. However, the
    relative placement of 'output' and 'blah' entries must retain their order.

An example of order being turned both the 'value' and 'name' contexts:

    SCHEMA FRAGMENT
        
        ordered False
        name blah
            value
                ordered False
        name output
            value
                ordered False
        
    DOCUMENT FRAGMENT
    
        blah 1
        blah 2
        output joe
        output jerry

    SAME:
    
        output jerry
        output joe
        blah 2
        blah 1

    JSON INTERPRETATION:
    
        {blah: {1: None, 2:None}, output: {joe: None, jerry: None}}
        
    or

        {blah: [1, 2], output: [joe, jerry]}
    
    None of the entries have a retained order. As long as the same four named
    elements are in the document, the order is not important.
    
    
--------------------------------------
JSON and Pythonic INTEPRETATION
--------------------------------------

The following elements can influence interpretation:

* 'treatment' statements
* 'ordered' statements in name and value contexts
* existence of subtending 'name' entries in the schema

THE DEFAULT:

As a worst-case fallback, a MARDS document is represented as a list-of-tuples containing lists-of-tuples. It is the form of:

  [(name, value, _list_), ...]
  
Where list _can_ be another list of (name, value, list) to subtend the name/value.
  
For example:

    SCHEMA:
    
        name blah
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = [
        ('blah', '1', [
            ('size', 'x'),
            ('size', 'xl')
        ]),
        ('blah', '1', [
            ('size', 'x'),
            ('size', 'xl')
        ]),
        ('output', 'joe'),
        ('output, 'jerry'),
        ('corn', '1994')
    ]
    
    # code to get the sizes of 'blah 1'
    size_items = [x[2] for x in doc if x[0]=='blah' and x[1]=='1']
    sizes = [x[1] for x in size_items[0]]
    
    # code to get the 'corn' value
    corn_year = [x[1] for x in doc if x[0]=='corn'][0]

ORDERED

Adding an 'ordered' statement of 'False' to the 'name' context converts a
name to a dicitonary key and any subtending values to a list (or list of
tuples). For example:

    SCHEMA:

        ordered False
        name blah
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': [
            ('1', [
                ('size', 'x'),
                ('size', 'xl')
            ]),
            ('2', [
                ('size', 'sm'),
                ('size', 'x')
            ]),
        'output': ['joe', 'jerry'],
        'corn': ['1994']
    }

    # code to get the sizes of 'blah 1'
    size_list = [x[1] for x in doc['blah'] if x[0]=='1']
    sizes = [x[1] for x in size_list]
    
    # code to get the 'corn' value
    corn_year = doc['corn'][0]

Going even further:

    SCHEMA:

        ordered False
        name blah
            ordered False
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': [
            ('1', {'size': ['x', 'xl']}),
            ('2', {'size': ['sm', 'x']})
        ],
        'output': ['joe', 'jerry'],
        'corn': ['1994']
    }

    # code to get the sizes of 'blah 1'
    sizes = [x[1]['size'] for x in doc['blah'] if x[0]=='1']
    
    # code to get the 'corn' value
    corn_year = doc['corn'][0]

    
If the 'ordered False' is used in a value context, then the those values are
used as dictionary keys IF there are any subtending name elements in the schema.
Otherwise it is still a list.

To keep things consistent, it is existence of 'name' elements in the schema that
determine the behavior, whether they are actually in the document is not important.

Example:
    
    SCHEMA:

        ordered False
        name blah
            ordered False
            value
                ordered False
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': {
            '1': {'size': ['x', 'xl']},
            '2': {'size': ['sm', 'x']}
        },
        'output': ['joe', 'jerry'],
        'corn': ['1994']
    }

    # code to get the sizes of 'blah 1'
    sizes = doc['blah']['1']['size']
    
    # code to get the 'corn' value
    corn_year = doc['corn'][0]

    
TREATMENT ONE, SUM, and AVERAGE

Adding a treament of 'one', 'sum', or 'average' to a name context, will
change the intpretation of the document. Specifically, it removes the
'list-like' behavior of the value IF it is already in the context of a
dictionary.

For example:

    SCHEMA:

        ordered False
        name blah
            ordered False
            value
                ordered False
            name size
        name output
        name corn
            treatment one
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

Would become, in python:

    doc = {
        'blah': {
            '1': {'size': ['x', 'xl']},
            '2': {'size': ['sm', 'x']}
        },
        'output': ['joe', 'jerry'],
        'corn': '1994'
    }

    # code to get the sizes of 'blah 1'
    sizes = doc['blah']['1']['size']
    
    # code to get the 'corn' value
    corn_year = doc['corn']

NOTE regarding ROLNE

The rolne data type, if used rather than python's built-in types, also makes
queries easy. The 'ordered' and 'treatment' clues are simply not needed. Using
the same example:

    SCHEMA:

        name blah
            name size
        name output
        name corn
    
    DOCUMENT:

        blah 1
            size x
            size xl
        blah 2
            size sm
            size x
        output joe
        output jerry
        corn 1994

    ROLNE CODE in Python:
        
    doc = MARDS.MARDS_to_rolne(text_document)    
    
    # code to get the sizes of 'blah 1'
    sizes = doc['blah', '1'].get_list("size")
    
    # code to get the (first) 'corn' value
    corn_year = doc.value('corn')

-------------------------
INSERT and RECURSION
-------------------------
MARDS let you "insert" a copy of another element with the 'insert' element.
The insert simply references another 'name' element with the same label. So,
instead of writing:

    name box
        name params
            name color
            name size
            name title
    name circle
        name params
            name color
            name size
            name title

one could simply write:

    name box
        name params
            name color
            name size
            name title
    name circle
        insert params

Of course, in order for the 'insert' to work, the referenced label must only
exist ONCE in the entire document.

The MARDS schema also supports recursion, but with 'recurse' rather than
'insert'. Othwerwise it behaves in a similar manner. For example:

    SCHEMA
    
        name document_title
        name summary
        name section
            value
                required
            name description
            recurse section

    EXAMPLE DOC
    
        document_title "The MARDS Manual"
        summary "A simply splendid manual explaining MARDS"
        section "Chapter 1"
            description "Introduction"
            section "1.1"
                description "About Me"
            section "1.2"
                description "Standards Used"
            section "2.3"
                description "Why Mards?"
                section "2.3.1"
                    descrption "No, seriously, why Mards?"
        section "Chapter 2"
            description "More Stuff"
        section "Chapter 3"
            description "blah blah blah"
            

Again, the label must unique in the document.

'recurse' also supports a sub-element called 'limit'. This essentially sets the
qty of recursive loops to go through. So,

    recurse my_name
        limit 5
        
Will only recurse 5 times before stopping. The 'default' for recurse is 12. It
should be noted that:

    recurse my_name
        limit 1

is almost the same thing as:

    insert my_name
    
The final difference simply being that recurse must be self-referential and
insert must not be.

SIDEBAR: If 'recurse' and 'insert' really do the same thing, why are
there two different elements? It was done purposefully to prevent
accidents on the part of the person designing the schema. The designers of
this schema have yet to come with a scenario where one needs an element to
be either. Generally, either:

A. The designer specifically means for it to be recursive. In which case flagging
it as non-recursive is useful for debugging. Or,

B. The designer did not intend for recursion and such recursion has came about from
a "hidden" loop of multiple inserts. A "a->b->c->a" type of loop. In that case,
flagging it as an error is very useful for debugging.

If a reason is found for a super-flexible "either", then it might be added
to the spec in a later release. It will very likely have a different element
name.

SIDEBAR: Why can't I have an unlimited 'recurse'? Philisophically, MARDS
documents _always_ resolve to static deterministic data sets. Allowing
infinite recursion prevents such a resolution.

Only a schema document can be recursive. A data document cannot (or
should not) be. 

----------------------------
TYPES
----------------------------

A new type is defined with a 'define_type' element.

Typically, a 'define_type' is first defined at the root of the document. If a type is defined at any
other level of indentation, then that type is limited to that context. While this is
possible, it is a highly discouranged practice.

As of version 1.0, a define_type is simply:

    define_type <label>
    
It is presumed an external program has been written to enfore its syntax.
What follows is a possible example of expanded syntax for version 1.1:

Example:

    SCHEMA:
    
        define_type length
            regex "\s*([0-9][0-9]*.?[0-9]*)\s*(\w*)\s*"
                group length
                group unit
                    find mm
                        calc length
                            formula n*1000
                    find cm
                        calc length
                            formula n*100
            extern_support True
            return length
            
        define_type boolean
            regex "\s*(.*)\s*"
                group bool
                    find true
                    find True
                        replace_with true
                    find 1
                        replace_with true
                    find false
                    find False
                        replace_with false
                    find 0
                        replace_with false
                    find_else_reject true
            extern_support False
            return bool

-------------------------------------
IMPORTS
-------------------------------------

On can declare the schema for a document on the top declaritive line:

    %%MARDS_en_1.0 thename

There can ONLY be one schema for a data document

Alternatively, one can embed a schema directly into the data
documnt with the '%%schema' element.

    %%MARDS_en_1.0
    %%schema
        name document_title
        name summary
        name section
            value
                required
            name description

%%MARDS_schema_en_1.0
import_type 3rdpart
    repository schema.xyz.com
import_type boolean
    local "%lib/big_boolean.schema"
        use my_boolean
import_type my_type
    direct http://www.outthere.com/my_type.mards
import_type integer
    repository common.mards.org
import_type length
    repository common.mards.org

One of the following three elements can subtend an 'import' or '%%MARDS_en_1.0' element:

    'local' means a schema document in the same location as this document.
        The string that follows is the name of the document. There is no
        exact standard for this string as it is presumed that any 'local'
        use is not meant to be universal.
        
        This is the presumed default. So,
        
            %%MARDS_en_1.0 thename.schema
            
        is the same as:
        
            %%MARDS_en_1.0 thename.schema
                local "thename.schema"

    'repository' are schemas managed by a common web site or system and
        are cached locally.
       
        The following is tried by default:
       
            import abc
                repository xyz.domain.com
        
        pulls from:
        
            https://repository.xyz.domain.com/schema?name=abc.schema
        
        The 'https://repository.' prefix and the '/schema?name=' and '{}.schema'
        suffixes are the
        defaults. These can be changed with 'prefix', 'middle', and 'suffix' sub
        elements.
        
    'direct' is a standardized uri used to retreive the MARDS schema doc.

